/* Sketch generated by the Arduino IoT Cloud Thing 
"Untitled" https://create.arduino.cc/cloud/things/c3edb65b-4bc9-402f-bcdf-9b222664dae9 Arduino IoT Cloud Variables description The following variables are automatically generated and updated when changes are made to the 
Thing float humidity;
float moisturePercentage;
CloudTemperatureSensor temperature;
int pumpState;
bool waterDetected;
Variables which are marked as READ/WRITE in the Cloud Thing will also have functions which are called when their values are changed from the Dashboard. These functions are generated with the Thing and added at the end of this sketch. */

#include <WiFi.h>
#include <DHT.h>
#include <ArduinoIoTCloud.h>
#include <Arduino_ConnectionHandler.h>
#include "thingProperties.h"

// ----------- Pines ----------
#define DHTPIN 4             // Pin del DHT11
#define DHTTYPE DHT11
#define SOIL_MOISTURE_PIN 32 // Sensor humedad del suelo
#define TRIG_PIN 26          // Sensor ultrasónico TRIG
#define ECHO_PIN 27          // Sensor ultrasónico ECHO
#define PUMP_PIN 5          // Bomba de agua (GPIO válido ESP32-S3)

// ----------- Calibración del sensor ----------
const int dryValue = 4095;   // suelo seco
const int wetValue = 2000;   // suelo húmedo

// ----------- Configuración caneca ----------
const float CANECA_ALTURA_VACIA = 32.0; // 32 cm cuando está vacía
const float NIVEL_AGUA_MINIMO = 5.0;    // Nivel mínimo de agua para operar (cm)

// ----------- Inicializar sensor DHT -----------
DHT dht(DHTPIN, DHTTYPE);

void setup() {
  Serial.begin(115200);
  dht.begin();

  pinMode(SOIL_MOISTURE_PIN, INPUT);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(PUMP_PIN, OUTPUT);
  digitalWrite(PUMP_PIN, LOW);

  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

// Función para medir nivel de agua con sensor ultrasónico
float medirNivelAgua() {
  // Limpiar el TRIG
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  
  // Enviar pulso de 10 microsegundos
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  
  // Medir el tiempo del pulso HIGH en ECHO
  long duration = pulseIn(ECHO_PIN, HIGH, 30000); // Timeout de 30ms
  
  // Si no hay eco, retornar 0 (sin agua)
  if (duration == 0) {
    return 0.0;
  }
  
  // Calcular distancia (velocidad del sonido 343 m/s = 0.0343 cm/microsegundo)
  float distancia = duration * 0.0343 / 2;
  
  // Calcular nivel de agua (altura vacía - distancia medida)
  float nivelAgua = CANECA_ALTURA_VACIA - distancia;
  
  // Asegurar que el nivel no sea negativo usando comparación simple
  if (nivelAgua < 0.0) {
    nivelAgua = 0.0;
  }
  
  return nivelAgua;
}

void loop() {
  ArduinoCloud.update();

  // ----------- Lectura de sensores -----------
  humidity = dht.readHumidity();
  temperature = dht.readTemperature();

  int soilMoisture = analogRead(SOIL_MOISTURE_PIN);
  moisturePercentage = map(soilMoisture, dryValue, wetValue, 0, 100);
  moisturePercentage = constrain(moisturePercentage, 0, 100);

  // Medir nivel de agua
  waterLevel = medirNivelAgua();

  // ----------- Mostrar datos en monitor serial -----------
  Serial.print("Humedad aire: "); Serial.print(humidity); Serial.print("%\t");
  Serial.print("Temp: "); Serial.print(temperature); Serial.print("°C\t");
  Serial.print("Suelo: "); Serial.print(moisturePercentage); Serial.print("%\t");
  Serial.print("Nivel agua: "); Serial.print(waterLevel); Serial.print(" cm\t");
  Serial.print("pumpState: "); Serial.println(pumpState);

  // ----------- Control de bomba según pumpState -----------
  if (pumpState == 0) {
    // OFF
    digitalWrite(PUMP_PIN, LOW);
    Serial.println("Bomba apagada (MANUAL OFF)");
  } 
  else if (pumpState == 1) {
    // ON manual - Solo si hay agua suficiente
    if (waterLevel > NIVEL_AGUA_MINIMO) {
      digitalWrite(PUMP_PIN, HIGH);
      Serial.println("Bomba encendida (MANUAL ON)");
    } else {
      digitalWrite(PUMP_PIN, LOW);
      Serial.println("Bomba bloqueada - Nivel de agua insuficiente");
    }
  } 
  else if (pumpState == 2) {
    // AUTO - Solo si hay agua suficiente y el suelo necesita riego
    if (moisturePercentage < 30 && waterLevel > NIVEL_AGUA_MINIMO) {
      digitalWrite(PUMP_PIN, HIGH);
      Serial.println("Bomba encendida (AUTO)");
    } else {
      digitalWrite(PUMP_PIN, LOW);
      if (moisturePercentage >= 30) {
        Serial.println("Bomba apagada - Suelo ya húmedo");
      } else if (waterLevel <= NIVEL_AGUA_MINIMO) {
        Serial.println("Bomba bloqueada - Nivel de agua insuficiente");
      }
    }
  }

  delay(2000);
}

// ----------- Función callback para cambios en la nube -----------
void onPumpStateChange() {
  Serial.print("Nuevo pumpState desde la nube: ");
  Serial.println(pumpState);
}

void onWaterLevelChange() {
  // Esta función se ejecuta cuando cambia el nivel de agua
  Serial.print("Nivel de agua actualizado: ");
  Serial.print(waterLevel);
  Serial.println(" cm");
}
